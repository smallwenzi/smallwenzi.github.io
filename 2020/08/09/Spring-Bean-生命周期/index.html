<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="wen" />



<meta name="description" content="问题 spring 如何产生Bean @Configuration注解的作用是什么，Spring是如何解析加了@Configuration注解的类？ Spring在什么时候对@ComponentScan、@ComponentScans注解进行了解析？ Spring什么时候解析了@Import注解，如何解析的？ Spring什么时候解析了@Bean注解？  如何产生bean1234567891011">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Bean 生命周期">
<meta property="og:url" content="https://smallwenzi.github.io/2020/08/09/Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/index.html">
<meta property="og:site_name" content="perter blog">
<meta property="og:description" content="问题 spring 如何产生Bean @Configuration注解的作用是什么，Spring是如何解析加了@Configuration注解的类？ Spring在什么时候对@ComponentScan、@ComponentScans注解进行了解析？ Spring什么时候解析了@Import注解，如何解析的？ Spring什么时候解析了@Bean注解？  如何产生bean1234567891011">
<meta property="og:locale">
<meta property="og:image" content="https://smallwenzi.github.io/2020/08/09/Spring-Bean-生命周期/DefaultListableBeanFactory.png">
<meta property="og:image" content="https://smallwenzi.github.io/2020/08/09/Spring-Bean-生命周期/ConfigurationClassPostProcessor.png">
<meta property="og:image" content="https://smallwenzi.github.io/2020/08/09/Spring-Bean-生命周期/AutowiredAnnotationBeanPostProcessor.png">
<meta property="og:image" content="https://smallwenzi.github.io/2020/08/09/Spring-Bean-生命周期/CommonAnnotationBeanPostProcessor.png">
<meta property="og:image" content="https://smallwenzi.github.io/2020/08/09/Spring-Bean-生命周期/PersistenceAnnotationBeanPostProcessor.png">
<meta property="og:image" content="https://smallwenzi.github.io/2020/08/09/Spring-Bean-生命周期/RootBeanDefinition.png">
<meta property="og:image" content="https://smallwenzi.github.io/2020/08/09/Spring-Bean-生命周期/AnnotatedGenericBeanDefinition.png">
<meta property="article:published_time" content="2020-08-09T12:38:00.000Z">
<meta property="article:modified_time" content="2020-08-18T13:36:41.156Z">
<meta property="article:author" content="wen">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://smallwenzi.github.io/2020/08/09/Spring-Bean-生命周期/DefaultListableBeanFactory.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="perter blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/head.jpg">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">



<link rel="stylesheet" href="/css/style.css">




<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Spring Bean 生命周期 | perter blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>





    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?4ddf556681628c050408be2e75f02c02";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>


<meta name="generator" content="Hexo 5.4.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/head.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>

        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:beityw@hotmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" rel="noopener" href="https://github.com/smallwenzi/smallwenzi.github.io" title="GitHub"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/DI/" rel="tag">DI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IOC%E5%AE%B9%E5%99%A8/" rel="tag">IOC容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Inversion-of-Control/" rel="tag">Inversion of Control</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMq/" rel="tag">RabbitMq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/atom/" rel="tag">atom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/githubpage/" rel="tag">githubpage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo-admin/" rel="tag">hexo-admin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/httpd/" rel="tag">httpd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jenkins/" rel="tag">jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jpa/" rel="tag">jpa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/notepad/" rel="tag">notepad</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nutch/" rel="tag">nutch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/plantuml/" rel="tag">plantuml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rabbitMq/" rel="tag">rabbitMq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/red-hat-Linux/" rel="tag">red hat Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/resttemplate/" rel="tag">resttemplate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rpm/" rel="tag">rpm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/session/" rel="tag">session</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/solr/" rel="tag">solr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/solr-master/" rel="tag">solr-master</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/solr-slave/" rel="tag">solr-slave</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-config/" rel="tag">spring config</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springAdmin/" rel="tag">springAdmin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springsession/" rel="tag">springsession</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thymeleaf/" rel="tag">thymeleaf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/" rel="tag">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/" rel="tag">tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/work/" rel="tag">work</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yum/" rel="tag">yum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/" rel="tag">依赖注入</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" rel="tag">单例模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E4%BD%9C/" rel="tag">工作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87/" rel="tag">工作效率</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://pages.github.com/">GitHub</a>
                    
                    </div>
                </section>
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/head.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:beityw@hotmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/smallwenzi/smallwenzi.github.io" title="GitHub"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-Spring-Bean-生命周期" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/08/09/Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="article-date">
      <time datetime="2020-08-09T12:38:00.000Z" itemprop="datePublished">2020-08-09</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Spring Bean 生命周期
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Spring/">Spring</a><a class="article-category-link" href="/categories/Spring/SpringFramework/">SpringFramework</a>
    </div>


        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul>
<li>spring 如何产生Bean</li>
<li>@Configuration注解的作用是什么，Spring是如何解析加了@Configuration注解的类？</li>
<li>Spring在什么时候对@ComponentScan、@ComponentScans注解进行了解析？</li>
<li>Spring什么时候解析了@Import注解，如何解析的？</li>
<li>Spring什么时候解析了@Bean注解？</li>
</ul>
<h1 id="如何产生bean"><a href="#如何产生bean" class="headerlink" title="如何产生bean"></a>如何产生bean</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.yanwen.springTest;</span><br><span class="line"></span><br><span class="line">import com.yanwen.springTest.service.MemberService;</span><br><span class="line">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@ComponentScan(&quot;com.yanwen.springTest&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">      AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">      System.out.println(annotationConfigApplicationContext.getBean(MemberService.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.yanwen.springTest.service;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class MemberService &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="/2020/08/07/spring源码编译/#新建Model">如何在spring源码中新建model及创建上面的代码</a><br><a href="/2020/08/08/spring源码（一）/#ApplicationContext">关于ApplicationContext</a><br><a href="https://www.processon.com/view/link/5f3bce04f346fb06decb7923" target="_blank" rel="noopener">spring实例化过程.png</a><br>以上代码：</p>
<ul>
<li>从一个Java的配置类中加载Spring应用上下文（AnnotationConfigApplicationContext）。</li>
<li>通过BeanFactory启动IoC容器时，并不会初始化配置文件中定义的Bean，初始化动作发生在第一个调用时。</li>
<li>对于单实例（singleton）的Bean来说，BeanFactory会缓存Bean实例，所以第二次使用getBean时直接从IoC容器缓存中获取Bean。</li>
</ul>
<h1 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h1><p>记住，一定要在电脑中打开源码，不然纯看是很累的。<br><a href="https://github.com/smallwenzi/springframeworkcode" target="_blank" rel="noopener">spring源码注释</a><br>分支是springcode</p>
<p>Spring bean 默认是单例<br>为了弄清楚Bean是怎么来的，花费了大把功夫，现在要把Bean Definition的加载、解析、处理、注册到bean工厂的过程记下来</p>
<ul>
<li>AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);<br><a href="#AnnotationConfigApplicationContext构造方法">实例化AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses</a><ul>
<li>this()<ul>
<li><a href="#GenericApplicationContext-构造方法">调用父类GenericApplicationContext的构造函数</a><ul>
<li>this.beanFactory = new DefaultListableBeanFactory();<br><a href="#DefaultListableBeanFactory-构造方法">实例化DefaultListableBeanFactory</a></li>
</ul>
</li>
<li>this.reader = new AnnotatedBeanDefinitionReader(this);<br><a href="#初始化一个Bean读取器AnnotatedBeanDefinitionReader">实例化AnnotatedBeanDefinitionReader</a><ul>
<li><a href="#AnnotationConfigUtils-registerAnnotationConfigProcessors">registerAnnotationConfigProcessors方法负责向容器里面注册相关的类</a></li>
</ul>
</li>
<li>this.scanner = new ClassPathBeanDefinitionScanner(this);<br>初始化一个扫描器，它仅仅是在我们外部手动调用 .scan 等方法才有用，常规方式是不会用到scanner对象的</li>
</ul>
</li>
<li><a href="#register-componentClasses">register(componentClasses);</a><ul>
<li><a href="#AnnotatedBeanDefinitionReader-类register-方法">AnnotatedBeanDefinitionReader 类register 方法</a><ul>
<li><a href="#AnnotatedBeanDefinitionReader的方法doRegisterBean">AnnotatedBeanDefinitionReader的方法doRegisterBean</a> 把appconfig注册至bean容器中但是未实例化</li>
</ul>
</li>
</ul>
</li>
<li><a href="#refresh">refresh();</a><ul>
<li>prepareRefresh();<br>刷新前的预处理;</li>
<li>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<br>获取BeanFactory；默认实现是DefaultListableBeanFactory，在创建容器的时候创建的</li>
<li>prepareBeanFactory(beanFactory);<br>BeanFactory的预准备工作（BeanFactory进行一些设置，比如context的类加载器，BeanPostProcessor和XXXAware自动装配等）</li>
<li>postProcessBeanFactory(beanFactory);<br>BeanFactory准备工作完成后进行的后置处理工作</li>
<li>invokeBeanFactoryPostProcessors(beanFactory);<br>执行BeanFactoryPostProcessor的方法；</li>
<li>registerBeanPostProcessors(beanFactory);<br>注册BeanPostProcessor（Bean的后置处理器），在创建bean的前后等执行</li>
<li>initMessageSource();<br>初始化MessageSource组件（做国际化功能；消息绑定，消息解析）；</li>
<li>initApplicationEventMulticaster();<br>初始化事件派发器</li>
<li>onRefresh();<br>子类重写这个方法，在容器刷新的时候可以自定义逻辑；如创建Tomcat，Jetty等WEB服务器</li>
<li>registerListeners();<br>注册应用的监听器。就是注册实现了ApplicationListener接口的监听器bean，这些监听器是注册到ApplicationEventMulticaster中的</li>
<li>finishBeanFactoryInitialization(beanFactory);<br>初始化所有剩下的非懒加载的单例bean</li>
<li>finishRefresh();<br>完成context的刷新。主要是调用LifecycleProcessor的onRefresh()方法，并且发布事件（ContextRefreshedEvent）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="AnnotationConfigApplicationContext构造方法"><a href="#AnnotationConfigApplicationContext构造方法" class="headerlink" title="AnnotationConfigApplicationContext构造方法"></a>AnnotationConfigApplicationContext构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry &#123;</span><br><span class="line"></span><br><span class="line">	private final AnnotatedBeanDefinitionReader reader;</span><br><span class="line"></span><br><span class="line">	private final ClassPathBeanDefinitionScanner scanner;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">    这句代码调用以下方法</span><br><span class="line">   根据参数类型可以知道，其实可以传入多个annotatedClasses，但是这种情况出现的比较少</span><br><span class="line">  */</span><br><span class="line">	public AnnotationConfigApplicationContext(Class&lt;?&gt;... componentClasses) &#123;</span><br><span class="line">     //详细看AnnotationConfigApplicationContext 无参构造</span><br><span class="line">		this();</span><br><span class="line">		register(componentClasses);</span><br><span class="line">		refresh();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">   public AnnotationConfigApplicationContext() &#123;</span><br><span class="line">    ////调用父类GenericApplicationContext无参构造函数，初始化一个BeanFactory: DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()</span><br><span class="line">     //在IOC容器中初始化一个 注解bean读取器AnnotatedBeanDefinitionReader</span><br><span class="line">		this.reader = new AnnotatedBeanDefinitionReader(this);</span><br><span class="line">        //在IOC容器中初始化一个 按类路径扫描注解bean的 扫描器</span><br><span class="line">		this.scanner = new ClassPathBeanDefinitionScanner(this);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用无参构造函数，会先调用父类GenericApplicationContext的构造函数<ul>
<li>父类的构造函数里面就是初始化DefaultListableBeanFactory，并且赋值给beanFactory<ul>
<li>本类的构造函数里面，初始化了一个读取器：AnnotatedBeanDefinitionReader read，一个扫描器ClassPathBeanDefinitionScanner scanner</li>
</ul>
</li>
<li>scanner的用处不是很大，它仅仅是在我们外部手动调用 .scan 等方法才有用，常规方式是不会用到scanner对象的</li>
</ul>
</li>
<li></li>
<li></li>
</ul>
<h3 id="GenericApplicationContext-构造方法"><a href="#GenericApplicationContext-构造方法" class="headerlink" title="GenericApplicationContext 构造方法"></a>GenericApplicationContext 构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class GenericApplicationContext extends AbstractApplicationContext implements BeanDefinitionRegistry &#123;</span><br><span class="line"> 	private final DefaultListableBeanFactory beanFactory;</span><br><span class="line">    public GenericApplicationContext() &#123;</span><br><span class="line">    //初始化一个BeanFactory</span><br><span class="line">		this.beanFactory = new DefaultListableBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DefaultListableBeanFactory-构造方法"><a href="#DefaultListableBeanFactory-构造方法" class="headerlink" title="DefaultListableBeanFactory 构造方法"></a>DefaultListableBeanFactory 构造方法</h4><p>默认实现了ListableBeanFactory和BeanDefinitionRegistry接口，基于bean definition对象，是一个成熟的bean factroy。</p>
<p>最典型的应用是：在访问bean前，先注册所有的definition（可能从bean definition配置文件中）。使用预先建立的bean定义元数据对象，从本地的bean definition表中查询bean definition因而将不会花费太多成本。</p>
<p>DefaultListableBeanFactory既可以作为一个单独的beanFactory，也可以作为自定义beanFactory的父类。<br><img src="/2020/08/09/Spring-Bean-生命周期/DefaultListableBeanFactory.png" alt="DefaultListableBeanFactory类图"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory</span><br><span class="line">        implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable &#123;</span><br><span class="line">        //存储BeanDefinition对象</span><br><span class="line">	private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);</span><br><span class="line">    </span><br><span class="line">   	/** 存储 spring bean 单例对象  */</span><br><span class="line">	private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);</span><br><span class="line">	/**</span><br><span class="line">	 * Create a new DefaultListableBeanFactory.</span><br><span class="line">	 */</span><br><span class="line">	public DefaultListableBeanFactory() &#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="AbstractAutowireCapableBeanFactory构造方法"><a href="#AbstractAutowireCapableBeanFactory构造方法" class="headerlink" title="AbstractAutowireCapableBeanFactory构造方法"></a>AbstractAutowireCapableBeanFactory构造方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public AbstractAutowireCapableBeanFactory() &#123;</span><br><span class="line"></span><br><span class="line">super();</span><br><span class="line">   //自动装配时忽略指定接口或类的依赖注入</span><br><span class="line">	ignoreDependencyInterface(BeanNameAware.class);</span><br><span class="line">	ignoreDependencyInterface(BeanFactoryAware.class);</span><br><span class="line">	ignoreDependencyInterface(BeanClassLoaderAware.class);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h6 id="AbstractBeanFactory"><a href="#AbstractBeanFactory" class="headerlink" title="AbstractBeanFactory"></a>AbstractBeanFactory</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * Create a new AbstractBeanFactory.</span><br><span class="line">	 */</span><br><span class="line">	public AbstractBeanFactory() &#123;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化一个Bean读取器AnnotatedBeanDefinitionReader"><a href="#初始化一个Bean读取器AnnotatedBeanDefinitionReader" class="headerlink" title="//初始化一个Bean读取器AnnotatedBeanDefinitionReader"></a>//初始化一个Bean读取器AnnotatedBeanDefinitionReader</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.reader = new AnnotatedBeanDefinitionReader(this);</span><br></pre></td></tr></table></figure>
<h4 id="AnnotatedBeanDefinitionReader构造方法"><a href="#AnnotatedBeanDefinitionReader构造方法" class="headerlink" title="AnnotatedBeanDefinitionReader构造方法"></a>AnnotatedBeanDefinitionReader构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">	//这里的BeanDefinitionRegistry当然就是AnnotationConfigApplicationContext的实例了</span><br><span class="line">	this(registry, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AnnotatedBeanDefinitionReader 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public AnnotatedBeanDefinitionReader (BeanDefinitionRegistry registry, Environment environment) &#123;</span><br><span class="line">	Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);</span><br><span class="line">	Assert.notNull(environment, &quot;Environment must not be null&quot;);</span><br><span class="line">	this.registry = registry;</span><br><span class="line">	this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);</span><br><span class="line">	//让我们把目光移动到这个方法的最后一行，进入registerAnnotationConfigProcessors方法：</span><br><span class="line">this.registry 是    AnnotationConfigApplicationContext的实例了   AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="AnnotationConfigUtils-registerAnnotationConfigProcessors"><a href="#AnnotationConfigUtils-registerAnnotationConfigProcessors" class="headerlink" title="AnnotationConfigUtils.registerAnnotationConfigProcessors"></a>AnnotationConfigUtils.registerAnnotationConfigProcessors</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">	registerAnnotationConfigProcessors(registry, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在看registerAnnotationConfigProcessors方法</p>
<ul>
<li>这里会一连串注册好几个Bean，在这其中最重要的一个Bean（没有之一）就是BeanDefinitionRegistryPostProcessor Bean。<pre><code>* ConfigurationClassPostProcessor实现BeanDefinitionRegistryPostProcessor接口，
* BeanDefinitionRegistryPostProcessor接口又扩展了BeanFactoryPostProcessor接口，
* BeanFactoryPostProcessor是Spring的扩展点之一，
*  ConfigurationClassPostProcessor是Spring极为重要的一个类，必须牢牢的记住上面所说的这个类和它的继承关系。
* 除了注册了ConfigurationClassPostProcessor，还注册了其他Bean，其他Bean也都实现了其他接口，比如BeanPostProcessor等。
* BeanPostProcessor接口也是Spring的扩展点之一。
</code></pre></li>
</ul>
<p>执行完方法<br>beanDefs 有5个</p>
<ul>
<li>ConfigurationClassPostProcessor</li>
<li>AutowiredAnnotationBeanPostProcessor </li>
<li>CommonAnnotationBeanPostProcessor</li>
<li>EventListenerMethodProcessor</li>
<li>DefaultEventListenerFactory<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">// this.registry 是    AnnotationConfigApplicationContext的实例了   </span><br><span class="line">source=null</span><br><span class="line">	public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors(</span><br><span class="line">			BeanDefinitionRegistry registry, @Nullable Object source) &#123;</span><br><span class="line">           //这里返回AnnotationConfigApplicationContext对象中DefaultListableBeanFactory类实例</span><br><span class="line">		DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">BeanDefinition		if (beanFactory != null) &#123;</span><br><span class="line"></span><br><span class="line">			if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">				//用来支持Spring的Ordered类、@Order注解和@Priority注解。</span><br><span class="line">                beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">			if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">				beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;&gt;(8);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">		 * 注册解析我们配置类的后置处理器ConfigurationClassPostProcessor</span><br><span class="line">		 * org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">		 */</span><br><span class="line">		if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">			//如果不存在（当然这里肯定是不存在的），就通过RootBeanDefinition的构造方法获得ConfigurationClassPostProcessor的BeanDefinition，RootBeanDefinition是BeanDefinition的子类</span><br><span class="line">			RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">			def.setSource(source);</span><br><span class="line">			beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">		&#125;</span><br><span class="line">		/**</span><br><span class="line">		 * 注册处理@Autowired 注解的处理器AutowiredAnnotationBeanPostProcessor</span><br><span class="line">		 *</span><br><span class="line">		 org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">		 */</span><br><span class="line">		if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">			RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">			def.setSource(source);</span><br><span class="line">			beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 注册处理JSR规范的注解处理器CommonAnnotationBeanPostProcessor</span><br><span class="line">		 * org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">		 */</span><br><span class="line">		// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span><br><span class="line">		if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">			RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">			def.setSource(source);</span><br><span class="line">			beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 处理jpa注解的处理器org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor</span><br><span class="line">		 */</span><br><span class="line">		// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span><br><span class="line">		if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">			RootBeanDefinition def = new RootBeanDefinition();</span><br><span class="line">			try &#123;</span><br><span class="line">				def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">						AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">			&#125;</span><br><span class="line">			catch (ClassNotFoundException ex) &#123;</span><br><span class="line">				throw new IllegalStateException(</span><br><span class="line">						&quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			def.setSource(source);</span><br><span class="line">			beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 处理监听方法的注解解析器EventListenerMethodProcessor</span><br><span class="line">		 */</span><br><span class="line">		if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">			RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line">			def.setSource(source);</span><br><span class="line">			beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">		&#125;</span><br><span class="line">		/**</span><br><span class="line">		 * 注册事件监听器工厂</span><br><span class="line">		 */</span><br><span class="line">		if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">			RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line">			def.setSource(source);</span><br><span class="line">			beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return beanDefs;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h5><p><img src="/2020/08/09/Spring-Bean-生命周期/ConfigurationClassPostProcessor.png" alt="ConfigurationClassPostProcessor类图"></p>
<pre><code>* ConfigurationClassPostProcessor是一个BeanFactory的后置处理器，因此它的主要功能是参与BeanFactory的建造，在这个类中，会解析加了@Configuration的配置类，还会解析@ComponentScan、@ComponentScans注解扫描的包，以及解析@Import等注解。
* ConfigurationClassPostProcessor 实现了 BeanDefinitionRegistryPostProcessor 接口，而 BeanDefinitionRegistryPostProcessor 接口继承了 BeanFactoryPostProcessor 接口，所以 ConfigurationClassPostProcessor 中需要重写 postProcessBeanDefinitionRegistry() 方法和 postProcessBeanFactory() 方法。而ConfigurationClassPostProcessor类的作用就是通过这两个方法去实现的。
* ConfigurationClassPostProcessor这个类是Spring内置的一个BeanFactory后置处理器，是在this()方法中将其添加到BeanDefinitionMap中的
* [postProcessBeanDefinitionRegistry](#PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors方法中)调用
</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  registry是DefaultListableBeanFactory对象</span><br><span class="line">  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">	int registryId = System.identityHashCode(registry);</span><br><span class="line">	if (this.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">		throw new IllegalStateException(</span><br><span class="line">				&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot; + registry);</span><br><span class="line">	&#125;</span><br><span class="line">	if (this.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">		throw new IllegalStateException(</span><br><span class="line">				&quot;postProcessBeanFactory already called on this post-processor against &quot; + registry);</span><br><span class="line">	&#125;</span><br><span class="line">	this.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line">	processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>processConfigBeanDefinitions 方法 </p>
<ul>
<li>从Beanfactory找出含有Configuration 或Component或ComponentScan或Import或ImportResource类 目前只有appconfig类符合</li>
<li><p>ConfigurationClassParser.parse（）<br>解析appconfig（AnnotatedGenericBeanDefinition 定义）</p>
<ul>
<li><p>1 处理内部类</p>
<ul>
<li><p>2 处理@PropertySources注解：进行一些配置信息的解析</p>
</li>
<li><p>3 处理@ComponentScan注解：使用ComponentScanAnnotationParser扫描basePackage下的需要解析的类(@SpringBootApplication注解也包括了@ComponentScan注解，只不过basePackages是空的，空的话会去获取当前@Configuration修饰的类所在的包)，并注册到BeanFactory中(这个时候bean并没有进行实例化，而是进行了注册。具体的实例化在finishBeanFactoryInitialization方法中执行)。对于扫描出来的类，递归解析</p>
</li>
<li><p>4 处理@Import注解：先递归找出所有的注解，然后再过滤出只有@Import注解的类，得到@Import注解的值。比如查找@SpringBootApplication注解的@Import注解数据的话，首先发现@SpringBootApplication不是一个@Import注解，然后递归调用修饰了@SpringBootApplication的注解，发现有个@EnableAutoConfiguration注解，再次递归发现被@Import(EnableAutoConfigurationImportSelector.class)修饰，还有@AutoConfigurationPackage注解修饰，再次递归@AutoConfigurationPackage注解，发现被@Import(AutoConfigurationPackages.Registrar.class)注解修饰，所以@SpringBootApplication注解对应的@Import注解有2个，分别是@Import(AutoConfigurationPackages.Registrar.class)和@Import(EnableAutoConfigurationImportSelector.class)。找出所有的@Import注解之后，开始处理逻辑：</p>
<ul>
<li><p>遍历这些@Import注解内部的属性类集合</p>
</li>
<li><p>如果这个类是个ImportSelector接口的实现类，实例化这个ImportSelector，如果这个类也是DeferredImportSelector接口的实现类，那么加入ConfigurationClassParser的deferredImportSelectors属性中让第7步处理。否则调用ImportSelector的selectImports方法得到需要Import的类，然后对这些类递归做@Import注解的处理</p>
</li>
<li><p>如果这个类是ImportBeanDefinitionRegistrar接口的实现类，设置到配置类的importBeanDefinitionRegistrars属性中</p>
</li>
<li><p>其它情况下把这个类入队到ConfigurationClassParser的importStack(队列)属性中，然后把这个类当成是@Configuration注解修饰的类递归重头开始解析这个类</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>5 处理@ImportResource注解：获取@ImportResource注解的locations属性，得到资源文件的地址信息。然后遍历这些资源文件并把它们添加到配置类的importedResources属性中</p>
</li>
<li><p>6 处理@Bean注解：获取被@Bean注解修饰的方法，然后添加到配置类的beanMethods属性中</p>
</li>
<li><p>7 处理DeferredImportSelector：处理第3步@Import注解产生的DeferredImportSelector，进行selectImports方法的调用找出需要import的类，然后再调用第3步相同的处理逻辑处理</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"> public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">	List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();</span><br><span class="line">	/* 获得所有的BeanDefinition的Name，放入candidateNames数组</span><br><span class="line">	目前6个：</span><br><span class="line">	ConfigurationClassPostProcessor</span><br><span class="line">	AutowiredAnnotationBeanPostProcessor</span><br><span class="line">	CommonAnnotationBeanPostProcessor</span><br><span class="line">	EventListenerMethodProcessor</span><br><span class="line">	DefaultEventListenerFactory</span><br><span class="line">	appconfig</span><br><span class="line">	 */</span><br><span class="line">	String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">        //循环candidateNames数组</span><br><span class="line">	for (String beanName : candidateNames) &#123;</span><br><span class="line">		//根据beanName获得BeanDefinition</span><br><span class="line">		BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">		/*  内部有两个标记位来标记是否已经处理过了</span><br><span class="line">		 这里会引发一连串知识盲点</span><br><span class="line">		当我们注册配置类的时候，可以不加Configuration注解，</span><br><span class="line">		直接使用Component ComponentScan Import ImportResource注解，称之为Lite配置类</span><br><span class="line">		如果加了Configuration注解，就称之为Full配置类</span><br><span class="line">		 如果我们注册了Lite配置类，我们getBean这个配置类，会发现它就是原本的那个配置类</span><br><span class="line">		如果我们注册了Full配置类，我们getBean这个配置类，会发现它已经不是原本那个配置类了，而是已经被cgilb代理的类了</span><br><span class="line">		 写一个A类，其中有一个构造方法，打印出“你好”</span><br><span class="line">		 再写一个配置类，里面有两个bean注解的方法</span><br><span class="line">		 其中一个方法new了A 类，并且返回A的对象，把此方法称之为getA</span><br><span class="line">		 第二个方法又调用了getA方法</span><br><span class="line">		 如果配置类是Lite配置类，会发现打印了两次“你好”，也就是说A类被new了两次</span><br><span class="line">		 如果配置类是Full配置类，会发现只打印了一次“你好”，也就是说A类只被new了一次，因为这个类被cgilb代理了，方法已经被改写</span><br><span class="line">		 */</span><br><span class="line">		if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		/* 判断是否为配置类（有两种情况 一种是传统意义上的配置类，一种是普通的bean），</span><br><span class="line">		在这个方法内部，会做判断，这个配置类是Full配置类，还是Lite配置类，并且做上标记</span><br><span class="line">		满足条件，加入到configCandidates */</span><br><span class="line">		else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) &#123;</span><br><span class="line">			configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">       // 如果没有配置类，直接返回</span><br><span class="line">	// Return immediately if no @Configuration classes were found</span><br><span class="line">	if (configCandidates.isEmpty()) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">       //处理排序</span><br><span class="line">	// Sort by previously determined @Order value, if applicable</span><br><span class="line">	configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">		int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">		int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">		return Integer.compare(i1, i2);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	// Detect any custom bean name generation strategy supplied through the enclosing application context</span><br><span class="line">	SingletonBeanRegistry sbr = null;</span><br><span class="line">	// DefaultListableBeanFactory最终会实现SingletonBeanRegistry接口，所以可以进入到这个if</span><br><span class="line">	if (registry instanceof SingletonBeanRegistry) &#123;</span><br><span class="line">		sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">		if (!this.localBeanNameGeneratorSet) &#123;</span><br><span class="line">			//spring中可以修改默认的bean命名方式，这里就是看用户有没有自定义bean命名方式，虽然一般没有人会这么做</span><br><span class="line">			BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(</span><br><span class="line">					AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">			if (generator != null) &#123;</span><br><span class="line">				this.componentScanBeanNameGenerator = generator;</span><br><span class="line">				this.importBeanNameGenerator = generator;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (this.environment == null) &#123;</span><br><span class="line">		this.environment = new StandardEnvironment();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Parse each @Configuration class</span><br><span class="line">	ConfigurationClassParser parser = new ConfigurationClassParser(</span><br><span class="line">			this.metadataReaderFactory, this.problemReporter, this.environment,</span><br><span class="line">			this.resourceLoader, this.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">	Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">	Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">	do &#123;</span><br><span class="line">		//解析配置类（传统意义上的配置类或者是普通bean，核心来了） candidates 仅appConfig类</span><br><span class="line">		parser.parse(candidates);</span><br><span class="line">		parser.validate();</span><br><span class="line"></span><br><span class="line">		Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">		configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">		// Read the model and create bean definitions based on its content</span><br><span class="line">		if (this.reader == null) &#123;</span><br><span class="line">			this.reader = new ConfigurationClassBeanDefinitionReader(</span><br><span class="line">					registry, this.sourceExtractor, this.resourceLoader, this.environment,</span><br><span class="line">					this.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		//直到这一步才把Import的类，@Bean @ImportRosource 转换成BeanDefinition</span><br><span class="line">		this.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">		//把configClasses加入到alreadyParsed，代表</span><br><span class="line">		alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">		candidates.clear();</span><br><span class="line">		//获得注册器里面BeanDefinition的数量 和 candidateNames进行比较</span><br><span class="line">		//如果大于的话，说明有新的BeanDefinition注册进来了</span><br><span class="line">		if (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">			String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">			Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">			Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;();</span><br><span class="line">			//循环alreadyParsed。把类名加入到alreadyParsedClasses</span><br><span class="line">			for (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">				alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">			&#125;</span><br><span class="line">			for (String candidateName : newCandidateNames) &#123;</span><br><span class="line">				if (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">					BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line">					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp;</span><br><span class="line">							!alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">						candidates.add(new BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			candidateNames = newCandidateNames;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	while (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">	// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span><br><span class="line">	if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">		sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) &#123;</span><br><span class="line">		// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span><br><span class="line">		// for a shared cache since it&apos;ll be cleared by the ApplicationContext.</span><br><span class="line">		((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ConfigurationClassParser.parse方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">   public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) &#123;</span><br><span class="line">	//循环传进来的配置类</span><br><span class="line">	for (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">		BeanDefinition bd = holder.getBeanDefinition();</span><br><span class="line">		try &#123;</span><br><span class="line">			//如果获得BeanDefinition是AnnotatedBeanDefinition的实例</span><br><span class="line">			if (bd instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line">				parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">			&#125;</span><br><span class="line">			else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">				parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanDefinitionStoreException(</span><br><span class="line">					&quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//执行DeferredImportSelector</span><br><span class="line">	this.deferredImportSelectorHandler.process();</span><br><span class="line">&#125;</span><br><span class="line">   	protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException &#123;</span><br><span class="line">	processConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   protected void processConfigurationClass(ConfigurationClass configClass, Predicate&lt;String&gt; filter) throws IOException &#123;</span><br><span class="line">	//判断是否需要跳过</span><br><span class="line">	if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ConfigurationClass existingClass = this.configurationClasses.get(configClass);</span><br><span class="line">	if (existingClass != null) &#123;</span><br><span class="line">		if (configClass.isImported()) &#123;</span><br><span class="line">			if (existingClass.isImported()) &#123;</span><br><span class="line">				existingClass.mergeImportedBy(configClass);</span><br><span class="line">			&#125;</span><br><span class="line">			// Otherwise ignore new imported config class; existing non-imported class overrides it.</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// Explicit bean definition found, probably replacing an import.</span><br><span class="line">			// Let&apos;s remove the old one and go with the new one.</span><br><span class="line">			this.configurationClasses.remove(configClass);</span><br><span class="line">			this.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Recursively process the configuration class and its superclass hierarchy.</span><br><span class="line">	SourceClass sourceClass = asSourceClass(configClass, filter);</span><br><span class="line">	do &#123;</span><br><span class="line">		sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);</span><br><span class="line">	&#125;</span><br><span class="line">	while (sourceClass != null);</span><br><span class="line"></span><br><span class="line">	this.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Apply processing and build a complete &#123;@link ConfigurationClass&#125; by reading the</span><br><span class="line"> * annotations, members and methods from the source class. This method can be called</span><br><span class="line"> * multiple times as relevant sources are discovered.</span><br><span class="line"> * @param configClass the configuration class being build</span><br><span class="line"> * @param sourceClass a source class</span><br><span class="line"> * @return the superclass, or &#123;@code null&#125; if none found or previously processed</span><br><span class="line"> */</span><br><span class="line">@Nullable</span><br><span class="line">protected final SourceClass doProcessConfigurationClass(</span><br><span class="line">		ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter)</span><br><span class="line">		throws IOException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	if (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">		// Recursively process any member (nested) classes first</span><br><span class="line">		//递归处理内部类，一般不会写内部类</span><br><span class="line">		processMemberClasses(configClass, sourceClass, filter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Process any @PropertySource annotations</span><br><span class="line">	//处理@PropertySource注解，@PropertySource注解用来加载properties文件</span><br><span class="line">	for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">			sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">			org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">		if (this.environment instanceof ConfigurableEnvironment) &#123;</span><br><span class="line">			processPropertySource(propertySource);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			logger.info(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +</span><br><span class="line">					&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Process any @ComponentScan annotations</span><br><span class="line">	//获得ComponentScan注解具体的内容，ComponentScan注解除了最常用的basePackage之外，还有includeFilters，excludeFilters等</span><br><span class="line">	Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">			sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">	//如果没有打上ComponentScan，或者被@Condition条件跳过，就不再进入这个if</span><br><span class="line">	if (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">			!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">		//循环处理componentScans</span><br><span class="line">		for (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">			// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span><br><span class="line">			//componentScan就是@ComponentScan上的具体内容，sourceClass.getMetadata().getClassName()就是配置类的名称</span><br><span class="line">			Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">			// Check the set of scanned definitions for any further config classes and parse recursively if needed</span><br><span class="line">			for (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">				BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">				if (bdCand == null) &#123;</span><br><span class="line">					bdCand = holder.getBeanDefinition();</span><br><span class="line">				&#125;</span><br><span class="line">				if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) &#123;</span><br><span class="line">					//递归调用，因为可能组件类有被@Bean标记的方法，或者组件类本身也有ComponentScan等注解</span><br><span class="line">					parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//处理@Import注解</span><br><span class="line">	//@Import注解是spring中很重要的一个注解，Springboot大量应用这个注解</span><br><span class="line">	//@Import三种类，一种是Import普通类，一种是Import ImportSelector，还有一种是Import ImportBeanDefinitionRegistrar</span><br><span class="line">	//getImports(sourceClass)是获得import的内容，返回的是一个set</span><br><span class="line">	// Process any @Import annotations</span><br><span class="line">	processImports(configClass, sourceClass, getImports(sourceClass), filter, true);</span><br><span class="line"></span><br><span class="line">	// Process any @ImportResource annotations</span><br><span class="line">	//处理@ImportResource注解</span><br><span class="line">	AnnotationAttributes importResource =</span><br><span class="line">			AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">	if (importResource != null) &#123;</span><br><span class="line">		String[] resources = importResource.getStringArray(&quot;locations&quot;);</span><br><span class="line">		Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);</span><br><span class="line">		for (String resource : resources) &#123;</span><br><span class="line">			String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">			configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//处理@Bean的方法，可以看到获得了带有@Bean的方法后，不是马上转换成BeanDefinition，而是先用一个set接收</span><br><span class="line">	// Process individual @Bean methods</span><br><span class="line">	Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">	for (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">		configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Process default methods on interfaces</span><br><span class="line">	processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">	// Process superclass, if any</span><br><span class="line">	if (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">		String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">		if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp;</span><br><span class="line">				!this.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">			this.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">			// Superclass found, return its annotation metadata and recurse</span><br><span class="line">			return sourceClass.getSuperClass();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// No superclass -&gt; processing is complete</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h5><p> <img src="/2020/08/09/Spring-Bean-生命周期/AutowiredAnnotationBeanPostProcessor.png" alt="AutowiredAnnotationBeanPostProcessor类图"></p>
<pre><code> * AutowiredAnnotationBeanPostProcessor 将扫描 Spring 容器中所有 Bean，当发现 Bean 中拥有@Autowired 注释时就找到和其匹配（默认按类型匹配）的 Bean，并注入到对应的地方中去。  
*  关于作用后续内容会说到
</code></pre><h5 id="CommonAnnotationBeanPostProcessor"><a href="#CommonAnnotationBeanPostProcessor" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h5><p>  <img src="/2020/08/09/Spring-Bean-生命周期/CommonAnnotationBeanPostProcessor.png" alt="CommonAnnotationBeanPostProcessor图"></p>
<pre><code>* CommonAnnotationBeanPostProcessor类在spring中是一个极其重要的类，它负责解析@Resource、@WebServiceRef、@EJB三个注解。这三个注解都是定义在javax.*包下的注解，属于java中的注解
* 关于作用后续内容会说到
</code></pre><h5 id="PersistenceAnnotationBeanPostProcessor"><a href="#PersistenceAnnotationBeanPostProcessor" class="headerlink" title="PersistenceAnnotationBeanPostProcessor"></a>PersistenceAnnotationBeanPostProcessor</h5><p>   <img src="/2020/08/09/Spring-Bean-生命周期/PersistenceAnnotationBeanPostProcessor.png" alt="PersistenceAnnotationBeanPostProcessor图"></p>
<pre><code> * PersistenceAnnotationBeanPostProcessor是Spring提供的用于处理注解@PersistenceUnit和@PersistenceContext的BeanPostProcessor。用于注入相应的JPA资源:EntityManagerFactory和EntityManager (或者它们的子类变量)。
* 关于作用后续内容会说到
</code></pre><h5 id="EventListenerMethodProcessor"><a href="#EventListenerMethodProcessor" class="headerlink" title="EventListenerMethodProcessor"></a>EventListenerMethodProcessor</h5><pre><code>![EventListenerMethodProcessor图](Spring-Bean-生命周期/EventListenerMethodProcessor.png)
 * EventListenerMethodProcessor 是 Spring 事件机制中非常重要的一个组件。它管理了一组EventListenerFactory组件,用来将应用中每个使用@EventListener注解定义的事件监听方法变成一个ApplicationListener实例注册到容器。换句话讲，框架开发者，或者应用开发者使用注解@EventListener定义的事件处理方法，如果没有EventListenerMethodProcessor的发现和注册，是不会被容器看到和使用的。
* 关于作用后续内容会说到
</code></pre><h5 id="DefaultEventListenerFactory"><a href="#DefaultEventListenerFactory" class="headerlink" title="DefaultEventListenerFactory"></a>DefaultEventListenerFactory</h5><pre><code>![DefaultEventListenerFactory图](Spring-Bean-生命周期/DefaultEventListenerFactory.png)
 * 监听器工厂
* 关于作用后续内容会说到
</code></pre><h4 id="registerPostProcessor-方法"><a href="#registerPostProcessor-方法" class="headerlink" title="registerPostProcessor 方法"></a>registerPostProcessor 方法</h4><p>registerPostProcessor方法内部就是注册Bean，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static BeanDefinitionHolder registerPostProcessor(</span><br><span class="line">			BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName) &#123;</span><br><span class="line">	    //为BeanDefinition设置了一个Role，ROLE_INFRASTRUCTURE代表这是spring内部的，并非用户定义的</span><br><span class="line">		definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">		//BeanDefinitionRegistry是接口，实现类：AnnotationConfigApplicationContext 实现方法位于：GenericApplicationContext</span><br><span class="line">		//方法实现this.beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line"></span><br><span class="line">		registry.registerBeanDefinition(beanName, definition);</span><br><span class="line">		return new BeanDefinitionHolder(definition, beanName);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>RootBeanDefinition 是BeanDefinition接口子类<br>BeanDefinition是什么，顾名思义，它是用来描述Bean的，<ul>
<li>里面存放着关于Bean的一系列信息，比如Bean的作用域，Bean所对应的Class，</li>
<li>是否懒加载，是否Primary等等，这个BeanDefinition也相当重要，</li>
</ul>
</li>
</ul>
<p><img src="/2020/08/09/Spring-Bean-生命周期/RootBeanDefinition.png" alt="RootBeanDefinition类图"></p>
<p>至此，实例化AnnotatedBeanDefinitionReader reader分析完毕。</p>
<h3 id="初始化扫描器"><a href="#初始化扫描器" class="headerlink" title="初始化扫描器"></a>初始化扫描器</h3><p>this.scanner = new ClassPathBeanDefinitionScanner(this);</p>
<h3 id="register-componentClasses"><a href="#register-componentClasses" class="headerlink" title="register(componentClasses);"></a>register(componentClasses);</h3><ul>
<li>把传入的类进行注册，这里有两个情况，</li>
<li>传入传统的配置类</li>
<li>传入bean（虽然一般没有人会这么做</li>
<li>看到后面会知道spring把传统的带上@Configuration的配置类称之为FULL配置类，不带@Configuration的称之为Lite配置类</li>
<li>但是我们这里先把带上@Configuration的配置类称之为传统配置类，不带的称之为普通bean</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">//componentClasses= AppConfig.class</span><br><span class="line">public void register(Class&lt;?&gt;...componentClasses) &#123;</span><br><span class="line">		Assert.notEmpty(componentClasses, &quot;At least one component class must be specified&quot;);</span><br><span class="line">       //AnnotatedBeanDefinitionReader 类对象</span><br><span class="line">		this.reader.register(componentClasses);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AnnotatedBeanDefinitionReader-类register-方法"><a href="#AnnotatedBeanDefinitionReader-类register-方法" class="headerlink" title="AnnotatedBeanDefinitionReader 类register 方法"></a>AnnotatedBeanDefinitionReader 类register 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//componentClasses= AppConfig.class</span><br><span class="line">public void register (Class&lt;?&gt;... componentClasses) &#123;</span><br><span class="line">		for (Class&lt;?&gt; componentClass : componentClasses) &#123;</span><br><span class="line">			registerBean(componentClass);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AnnotatedBeanDefinitionReader-类-registerBean方法"><a href="#AnnotatedBeanDefinitionReader-类-registerBean方法" class="headerlink" title="AnnotatedBeanDefinitionReader 类 registerBean方法"></a>AnnotatedBeanDefinitionReader 类 registerBean方法</h4><pre><code>public void registerBean(Class&lt;?&gt; beanClass) {
    doRegisterBean(beanClass, null, null, null, null);
}
</code></pre><h4 id="AnnotatedBeanDefinitionReader的方法doRegisterBean"><a href="#AnnotatedBeanDefinitionReader的方法doRegisterBean" class="headerlink" title="AnnotatedBeanDefinitionReader的方法doRegisterBean"></a>AnnotatedBeanDefinitionReader的方法doRegisterBean</h4><ul>
<li>1 通过AnnotatedGenericBeanDefinition的构造方法，<br>   获得配置类的BeanDefinition，这里是不是似曾相似，<br>   在注册ConfigurationClassPostProcessor类的时候，<br>   也是通过构造方法去获得BeanDefinition的，只不过当时是通过RootBeanDefinition去获得，<br>   现在是通过AnnotatedGenericBeanDefinition去获得。</li>
<li>2 判断需不需要跳过注册，Spring中有一个@Condition注解，如果不满足条件，就会跳过这个类的注册。</li>
<li>3 然后是解析作用域，如果没有设置的话，默认为单例。</li>
<li>4 获得BeanName。</li>
<li>5 解析通用注解，填充到AnnotatedGenericBeanDefinition，解析的注解为Lazy，Primary，DependsOn，Role，Description。</li>
<li>6 限定符处理，不是特指@Qualifier注解，也有可能是Primary，或者是Lazy，或者是其他（理论上是任何注解，这里没有判断注解的有效性）。</li>
<li>7 把AnnotatedGenericBeanDefinition数据结构和beanName封装到一个对象中（这个不是很重要，可以简单的理解为方便传参）。</li>
<li>8 注册，最终会调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//beanClass= AppConfig.class</span><br><span class="line">其它参数都是null</span><br><span class="line">private &lt;T&gt; void doRegisterBean(Class&lt;T&gt; beanClass, @Nullable String name,</span><br><span class="line">			@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, @Nullable Supplier&lt;T&gt; supplier,</span><br><span class="line">			@Nullable BeanDefinitionCustomizer[] customizers) &#123;</span><br><span class="line">        //AnnotatedGenericBeanDefinition可以理解为一种数据结构，是用来描述Bean的，这里的作用就是把传入的标记了注解的类</span><br><span class="line">		//转为AnnotatedGenericBeanDefinition数据结构，里面有一个getMetadata方法，可以拿到类上的注解</span><br><span class="line">		AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line">		//判断是否需要跳过注解，spring中有一个@Condition注解，当不满足条件，这个bean就不会被解析</span><br><span class="line">		if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		abd.setInstanceSupplier(supplier);</span><br><span class="line">		//解析bean的作用域，如果没有设置的话，默认为单例</span><br><span class="line">		ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">		abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">		//获得beanName</span><br><span class="line">		String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));</span><br><span class="line">		//解析通用注解，填充到AnnotatedGenericBeanDefinition，解析的注解为Lazy，Primary，DependsOn，Role，Description</span><br><span class="line">		AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">		//限定符处理，不是特指@Qualifier注解，也有可能是Primary,或者是Lazy，或者是其他（理论上是任何注解，这里没有判断注解的有效性），如果我们在外面，以类似这种</span><br><span class="line">		//AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(Appconfig.class);常规方式去初始化spring，</span><br><span class="line">		//qualifiers永远都是空的，包括上面的name和instanceSupplier都是同样的道理</span><br><span class="line">		//但是spring提供了其他方式去注册bean，就可能会传入了</span><br><span class="line">		if (qualifiers != null) &#123;</span><br><span class="line">			//可以传入qualifier数组，所以需要循环处理</span><br><span class="line">			for (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line"></span><br><span class="line">				//Primary注解优先</span><br><span class="line">				if (Primary.class == qualifier) &#123;</span><br><span class="line">					abd.setPrimary(true);</span><br><span class="line">				&#125;</span><br><span class="line">				//Lazy注解</span><br><span class="line">				else if (Lazy.class == qualifier) &#123;</span><br><span class="line">					abd.setLazyInit(true);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123; //其他，AnnotatedGenericBeanDefinition有个Map&lt;String,AutowireCandidateQualifier&gt;属性，直接push进去</span><br><span class="line">					abd.addQualifier(new AutowireCandidateQualifier(qualifier));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (customizers != null) &#123;</span><br><span class="line">			for (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">				customizer.customize(abd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//这个方法用处不大，就是把AnnotatedGenericBeanDefinition数据结构和beanName封装到一个对象中</span><br><span class="line">		BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);</span><br><span class="line">		definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);</span><br><span class="line">		//注册，最终会调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册，</span><br><span class="line">		//DefaultListableBeanFactory维护着一系列信息，比如beanDefinitionNames，beanDefinitionMap</span><br><span class="line">		//beanDefinitionNames是一个List&lt;String&gt;,用来保存beanName</span><br><span class="line">		//beanDefinitionMap是一个Map,用来保存beanName和beanDefinition</span><br><span class="line">		BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>AnnotatedGenericBeanDefinition<br>类注解初始化<br><img src="/2020/08/09/Spring-Bean-生命周期/AnnotatedGenericBeanDefinition.png" alt="AnnotatedGenericBeanDefinition类图"></li>
</ul>
<h3 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h3><p>Spring容器创建之后，会调用它的refresh方法刷新Spring应用的上下文。</p>
<h4 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh();"></a>prepareRefresh();</h4><p>//刷新预处理，和主流程关系不大，就是保存了容器的启动时间，启动标志等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">protected void prepareRefresh() &#123;</span><br><span class="line">	// Switch to active.</span><br><span class="line">	this.startupDate = System.currentTimeMillis();</span><br><span class="line">	this.closed.set(false);</span><br><span class="line">	this.active.set(true);</span><br><span class="line"></span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(&quot;Refreshing &quot; + this);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			logger.debug(&quot;Refreshing &quot; + getDisplayName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 空方法</span><br><span class="line">	initPropertySources();</span><br><span class="line"></span><br><span class="line">	// 验证环境信息里一些必须存在的属性</span><br><span class="line">	getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">	// Store pre-refresh ApplicationListeners...</span><br><span class="line">	if (this.earlyApplicationListeners == null) &#123;</span><br><span class="line">		this.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		// Reset local application listeners to pre-refresh state.</span><br><span class="line">		this.applicationListeners.clear();</span><br><span class="line">		this.applicationListeners.addAll(this.earlyApplicationListeners);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Allow for the collection of early ApplicationEvents,</span><br><span class="line">	// to be published once the multicaster is available...</span><br><span class="line">	this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory"><a href="#ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory" class="headerlink" title="ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();"></a>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</h4><p>获取AnnotationConfigApplicationContext 中<br>DefaultListableBeanFactory对象，DefaultListableBeanFactory是ConfigurableListableBeanFactory子类</p>
<h4 id="prepareBeanFactory-beanFactory"><a href="#prepareBeanFactory-beanFactory" class="headerlink" title="prepareBeanFactory(beanFactory);"></a>prepareBeanFactory(beanFactory);</h4><p>配置这个工厂的标准环境，比如context的类加载器和post-processors后处理器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * 设置了一个类加载器</span><br><span class="line">	 * 设置了bean表达式解析器</span><br><span class="line">	 * 添加了属性编辑器的支持</span><br><span class="line">	 * 添加了一个后置处理器：ApplicationContextAwareProcessor，此后置处理器实现了BeanPostProcessor接口</span><br><span class="line">	 * 设置了一些忽略自动装配的接口</span><br><span class="line">	 * 设置了一些允许自动装配的接口，并且进行了赋值操作</span><br><span class="line">	 * 在容器中还没有XX的bean的时候，帮我们注册beanName为XX的singleton bean</span><br><span class="line">	 */</span><br><span class="line">	protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">		// Tell the internal bean factory to use the context&apos;s class loader etc.</span><br><span class="line">		//设置类加载器</span><br><span class="line">		beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">		//设置bean表达式解析器</span><br><span class="line">		beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">		//属性编辑器支持</span><br><span class="line">		beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</span><br><span class="line"></span><br><span class="line">		//添加一个后置处理器：ApplicationContextAwareProcessor，此后置处理处理器实现了BeanPostProcessor接口</span><br><span class="line">		// Configure the bean factory with context callbacks.</span><br><span class="line">		beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class="line">		//以下接口，忽略自动装配</span><br><span class="line">		beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">		//以下接口，允许自动装配,第一个参数是自动装配的类型，，第二个字段是自动装配的值</span><br><span class="line">		// BeanFactory interface not registered as resolvable type in a plain factory.</span><br><span class="line">		// MessageSource registered (and found for autowiring) as a bean.</span><br><span class="line">		beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">		beanFactory.registerResolvableDependency(ResourceLoader.class, this);</span><br><span class="line">		beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</span><br><span class="line">		beanFactory.registerResolvableDependency(ApplicationContext.class, this);</span><br><span class="line"></span><br><span class="line">		//添加一个后置处理器：ApplicationListenerDetector，此后置处理器实现了BeanPostProcessor接口</span><br><span class="line">		// Register early post-processor for detecting inner beans as ApplicationListeners.</span><br><span class="line">		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br><span class="line"></span><br><span class="line">		// Detect a LoadTimeWeaver and prepare for weaving, if found.</span><br><span class="line">		if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">			// Set a temporary ClassLoader for type matching.</span><br><span class="line">			beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//如果没有注册过bean名称为XXX，spring就自己创建一个名称为XXX的singleton bean</span><br><span class="line">		// 注册环境变量</span><br><span class="line">		if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">		&#125;</span><br><span class="line">		if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">		&#125;</span><br><span class="line">		if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>ApplicationContextAwareProcessor<br>ApplicationContextAwareProcessor是一个Spring内部工具，它实现了接口BeanPostProcessor,用于向实现了如下某种Aware接口的bean设置ApplicationContext中相应的属性:</p>
<ul>
<li>EnvironmentAware</li>
<li>EmbeddedValueResolverAware</li>
<li>ResourceLoaderAware</li>
<li>ApplicationEventPublisherAware</li>
<li>MessageSourceAware</li>
<li>ApplicationContextAware<br>ApplicationContextAwareProcessor自己会被应用程序上下文自动注册到bean容器,不需要应用开发人员操心<br>后续内容会分析作用</li>
</ul>
</li>
<li><p>ApplicationListenerDetector</p>
<ul>
<li><p>1、在Bean初始化完成之后：如果Bean是单例的则并且bean instanceof ApplicationListener。加入到this.applicationListeners中。</p>
</li>
<li><p>2、在Bean销毁之前搞事情： 如果Bean是一个ApplicationListener，则会从ApplicationEventMulticaster（事件广播器）中提前删除了<br>后续内容会分析作用</p>
</li>
</ul>
</li>
<li>LoadTimeWeaverAwareProcessor<br>增加对 AspectJ 的支持<br>后续说到aop会详细说<h4 id="postProcessBeanFactory-beanFactory"><a href="#postProcessBeanFactory-beanFactory" class="headerlink" title="postProcessBeanFactory(beanFactory);"></a>postProcessBeanFactory(beanFactory);</h4>空方法<h4 id="invokeBeanFactoryPostProcessors-beanFactory"><a href="#invokeBeanFactoryPostProcessors-beanFactory" class="headerlink" title="invokeBeanFactoryPostProcessors(beanFactory);"></a>invokeBeanFactoryPostProcessors(beanFactory);</h4>在Spring容器中找出实现了BeanFactoryPostProcessor接口的processor并执行。Spring容器会委托给PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法执行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">		//spring允许我们手动添加BeanFactoryPostProcessor</span><br><span class="line">		//即：annotationConfigApplicationContext.addBeanFactoryPostProcessor(XXX);</span><br><span class="line">		//getBeanFactoryPostProcessors() 在外部可以手动添加一个后置处理器，而不是交给Spring去扫描</span><br><span class="line">		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">		// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span><br><span class="line">		// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span><br><span class="line">		if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">			beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors方法"><a href="#PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors方法" class="headerlink" title="PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors方法"></a>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors方法</h5><p>先介绍两个接口：</p>
<ul>
<li>BeanFactoryPostProcessor：用来修改Spring容器中已经存在的bean的定义，使用ConfigurableListableBeanFactory对bean进行处理</li>
<li>BeanDefinitionRegistryPostProcessor：继承BeanFactoryPostProcessor，作用跟BeanFactoryPostProcessor一样，只不过是使用BeanDefinitionRegistry对bean进行处理</li>
</ul>
<p>过程：</p>
<ul>
<li><p>beanFactory是DefaultListableBeanFactory，是BeanDefinitionRegistry的实现类，所以肯定满足if</p>
<ul>
<li>1 定义了一个Set（processedBeans），装载BeanName，后面会根据这个Set，来判断后置处理器是否被执行过了。</li>
<li><p>2 定义了两个List，</p>
<ul>
<li>一个是regularPostProcessors，用来装载BeanFactoryPostProcessor</li>
</ul>
<ul>
<li>一个是registryProcessors用来装载BeanDefinitionRegistryPostProcessor，其中BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor；BeanDefinitionRegistryPostProcessor有两个方法，一个是独有的postProcessBeanDefinitionRegistry方法，一个是父类的postProcessBeanFactory方法。</li>
</ul>
</li>
<li><p>3 循环传进来的beanFactoryPostProcessors，上面已经解释过了，一般情况下，这里永远都是空的，只有手动add beanFactoryPostProcessor，这里才会有数据。我们假设beanFactoryPostProcessors有数据，进入循环，判断postProcessor是不是BeanDefinitionRegistryPostProcessor，因为BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor，所以这里先要判断是不是BeanDefinitionRegistryPostProcessor，是的话，执行postProcessBeanDefinitionRegistry方法，然后把对象装到registryProcessors里面去，不是的话，就装到regularPostProcessors。</p>
</li>
<li><p>4 定义了一个临时变量：currentRegistryProcessors，用来装载BeanDefinitionRegistryPostProcessor。</p>
</li>
<li><p>5 getBeanNamesForType，顾名思义，是根据类型查到BeanNames，这里有一点需要注意，就是去哪里找，点开这个方法的话，就知道是循环beanDefinitionNames去找，这个方法以后也会经常看到。这里传了BeanDefinitionRegistryPostProcessor.class，就是找到类型为BeanDefinitionRegistryPostProcessor的后置处理器，并且赋值给postProcessorNames。一般情况下，只会找到一个，就是org.springframework.context.annotation.internalConfigurationAnnotationProcessor，也就是ConfigurationAnnotationProcessor。这里有一个问题，为什么我自己写了个类，实现了BeanDefinitionRegistryPostProcessor接口，也打上了@Component注解，但是这里没有获得，因为直到这一步，Spring还没有完成扫描，扫描是在ConfigurationClassPostProcessor类中完成的，也就是下面第一个invokeBeanDefinitionRegistryPostProcessors方法。</p>
</li>
<li><p>6 循环postProcessorNames，其实也就是org.springframework.context.annotation.internalConfigurationAnnotationProcessor，</p>
<ul>
<li>判断此后置处理器是否实现了PriorityOrdered接口（ConfigurationAnnotationProcessor也实现了PriorityOrdered接口），如果实现了，把它添加到currentRegistryProcessors这个临时变量中，再放入processedBeans，代表这个后置处理已经被处理过了(当然现在还没有处理，但是马上就要处理了)</li>
</ul>
</li>
<li>7 进行排序，PriorityOrdered是一个排序接口，如果实现了它，就说明此后置处理器是有顺序的，所以需要排序。当然目前这里只有一个后置处理器，就是ConfigurationClassPostProcessor。</li>
<li>8 把currentRegistryProcessors合并到registryProcessors，为什么需要合并？因为一开始spring只会执行BeanDefinitionRegistryPostProcessor独有的方法，而不会执行BeanDefinitionRegistryPostProcessor父类的方法，即BeanFactoryProcessor接口中的方法，所以需要把这些后置处理器放入一个集合中，后续统一执行BeanFactoryProcessor接口中的方法。当然目前这里只有一个后置处理器，就是ConfigurationClassPostProcessor。</li>
<li>9 可以理解为执行currentRegistryProcessors中的ConfigurationClassPostProcessor中的postProcessBeanDefinitionRegistry方法，这就是Spring设计思想的体现了，在这里体现的就是其中的热插拔，插件化开发的思想。Spring中很多东西都是交给插件去处理的，这个后置处理器就相当于一个插件，如果不想用了，直接不添加就是了。这个方法特别重要，我们后面会详细说来。</li>
<li>10 清空currentRegistryProcessors，因为currentRegistryProcessors是一个临时变量，已经完成了目前的使命，所以需要清空，当然后面还会用到。</li>
<li>11 再次根据BeanDefinitionRegistryPostProcessor获得BeanName，然后进行循环，看这个后置处理器是否被执行过了，如果没有被执行过，也实现了Ordered接口的话，把此后置处理器推送到currentRegistryProcessors和processedBeans中。这里就可以获得我们定义的，并且打上@Component注解的后置处理器了，因为Spring已经完成了扫描，但是这里需要注意的是，由于ConfigurationClassPostProcessor在上面已经被执行过了，所以虽然可以通过getBeanNamesForType获得，但是并不会加入到currentRegistryProcessors和processedBeans。</li>
<li>12 处理排序。</li>
<li>13 合并Processors，合并的理由和上面是一样的。</li>
<li>14 执行我们自定义的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法。</li>
<li>15 清空临时变量。</li>
<li>16 在上面的方法中，仅仅是执行了实现了Ordered接口的BeanDefinitionRegistryPostProcessor，这里是执行没有实现Ordered接口的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法。</li>
<li>17 regularPostProcessors装载BeanFactoryPostProcessor，执行BeanFactoryPostProcessor的postProcessBeanFactory方法</li>
<li>18 regularPostProcessors一般情况下，是不会有数据的，只有在外面手动添加BeanFactoryPostProcessor，才会有数据</li>
<li>19 查找实现了BeanFactoryPostProcessor的后置处理器，并且执行后置处理器中的方法。和上面的逻辑差不多，不再详细说明。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line">//beanFactory=DefaultListableBeanFactory</span><br><span class="line">//beanFactoryPostProcessors 没有添加 所以size=0</span><br><span class="line">public static void invokeBeanFactoryPostProcessors(</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123;</span><br><span class="line"></span><br><span class="line">		// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span><br><span class="line">		Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();</span><br><span class="line">       //beanFactory是DefaultListableBeanFactory，是BeanDefinitionRegistry的实现类，所以肯定满足if</span><br><span class="line">		if (beanFactory instanceof BeanDefinitionRegistry) &#123;</span><br><span class="line">			BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">			//regularPostProcessors 用来存放BeanFactoryPostProcessor，</span><br><span class="line">			List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">			//registryProcessors 用来存放BeanDefinitionRegistryPostProcessor,BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor</span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">			/*</span><br><span class="line">			循环传进来的beanFactoryPostProcessors，正常情况下，beanFactoryPostProcessors肯定没有数据</span><br><span class="line">			因为beanFactoryPostProcessors是获得手动添加的，而不是spring扫描的</span><br><span class="line">			只有手动调用annotationConfigApplicationContext.addBeanFactoryPostProcessor(XXX)才会有数据</span><br><span class="line">			*/</span><br><span class="line"></span><br><span class="line">			for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">			/* 判断postProcessor是不是BeanDefinitionRegistryPostProcessor，因为BeanDefinitionRegistryPostProcessor</span><br><span class="line">				 扩展了BeanFactoryPostProcessor，所以这里先要判断是不是BeanDefinitionRegistryPostProcessor</span><br><span class="line">				是的话，直接执行postProcessBeanDefinitionRegistry方法，然后把对象装到registryProcessors里面去</span><br><span class="line"></span><br><span class="line">			 */</span><br><span class="line">				if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">					BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">							(BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">					registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">					registryProcessors.add(registryProcessor);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					regularPostProcessors.add(postProcessor);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="line">			// uninitialized to let the bean factory post-processors apply to them!</span><br><span class="line">			// Separate between BeanDefinitionRegistryPostProcessors that implement</span><br><span class="line">			// PriorityOrdered, Ordered, and the rest.</span><br><span class="line"></span><br><span class="line">			/* 一个临时变量，用来装载BeanDefinitionRegistryPostProcessor</span><br><span class="line">			BeanDefinitionRegistry继承了PostProcessorBeanFactoryPostProcessor</span><br><span class="line">			 */</span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span><br><span class="line">			/*</span><br><span class="line">			 获得实现BeanDefinitionRegistryPostProcessor接口的类的BeanName:org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">			 对象是：ConfigurationClassPostProcessor</span><br><span class="line">			 */</span><br><span class="line">			String[] postProcessorNames =</span><br><span class="line">					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">			for (String ppName : postProcessorNames) &#123;</span><br><span class="line">				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">					/*</span><br><span class="line">					获得ConfigurationClassPostProcessor类，并且放到currentRegistryProcessors</span><br><span class="line">					ConfigurationClassPostProcessor是很重要的一个类，它实现了BeanDefinitionRegistryPostProcessor接口</span><br><span class="line">					BeanDefinitionRegistryPostProcessor接口又实现了BeanFactoryPostProcessor接口</span><br><span class="line">					ConfigurationClassPostProcessor是极其重要的类</span><br><span class="line">					里面执行了扫描Bean，Import，ImportResouce等各种操作</span><br><span class="line">					用来处理配置类（有两种情况 一种是传统意义上的配置类，一种是普通的bean）的各种逻辑</span><br><span class="line">					 */</span><br><span class="line">					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					//把name放到processedBeans，后续会根据这个集合来判断处理器是否已经被执行过了</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//处理排序</span><br><span class="line">			sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">			/* 合并Processors，为什么要合并，因为registryProcessors是装载BeanDefinitionRegistryPostProcessor的</span><br><span class="line">			一开始的时候，spring只会执行BeanDefinitionRegistryPostProcessor独有的方法</span><br><span class="line">			而不会执行BeanDefinitionRegistryPostProcessor父类的方法，即BeanFactoryProcessor的方法</span><br><span class="line">			所以这里需要把处理器放入一个集合中，后续统一执行父类的方法</span><br><span class="line">			 */</span><br><span class="line">			registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">			/*可以理解为执行ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry方法</span><br><span class="line">			Spring热插播的体现，像ConfigurationClassPostProcessor就相当于一个组件，Spring很多事情就是交给组件去管理</span><br><span class="line">			如果不想用这个组件，直接把注册组件的那一步去掉就可以</span><br><span class="line">			 */</span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">			//因为currentRegistryProcessors是一个临时变量，所以需要清除</span><br><span class="line">			currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span><br><span class="line">			// 再次根据BeanDefinitionRegistryPostProcessor获得BeanName，看这个BeanName是否已经被执行过了，有没有实现Ordered接口</span><br><span class="line">			// 如果没有被执行过，也实现了Ordered接口的话，把对象推送到currentRegistryProcessors，名称推送到processedBeans</span><br><span class="line">			// 如果没有实现Ordered接口的话，这里不把数据加到currentRegistryProcessors，processedBeans中，后续再做处理</span><br><span class="line">			// 这里才可以获得我们定义的实现了BeanDefinitionRegistryPostProcessor的Bean</span><br><span class="line">			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">			for (String ppName : postProcessorNames) &#123;</span><br><span class="line">				if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//处理排序</span><br><span class="line">			sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">			//合并Processors</span><br><span class="line">			registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">			//执行我们自定义的BeanDefinitionRegistryPostProcessor</span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">			//清空临时变量</span><br><span class="line">			currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">			// 上面的代码是执行了实现了Ordered接口的BeanDefinitionRegistryPostProcessor，</span><br><span class="line">			// 下面的代码就是执行没有实现Ordered接口的BeanDefinitionRegistryPostProcessor</span><br><span class="line">			// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span><br><span class="line">			boolean reiterate = true;</span><br><span class="line">			while (reiterate) &#123;</span><br><span class="line">				reiterate = false;</span><br><span class="line">				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">				for (String ppName : postProcessorNames) &#123;</span><br><span class="line">					if (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">						currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">						processedBeans.add(ppName);</span><br><span class="line">						reiterate = true;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">				registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">				invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">				currentRegistryProcessors.clear();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span><br><span class="line">			//registryProcessors集合装载BeanDefinitionRegistryPostProcessor</span><br><span class="line">			//上面的代码是执行子类独有的方法，这里需要再把父类的方法也执行一次</span><br><span class="line">			invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">			//regularPostProcessors装载BeanFactoryPostProcessor，执行BeanFactoryPostProcessor的方法</span><br><span class="line">			//但是regularPostProcessors一般情况下，是不会有数据的，只有在外面手动添加BeanFactoryPostProcessor，才会有数据</span><br><span class="line">			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		else &#123;</span><br><span class="line">			// Invoke factory processors registered with the context instance.</span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="line">		// uninitialized to let the bean factory post-processors apply to them!</span><br><span class="line">		//找到BeanFactoryPostProcessor实现类的BeanName数组</span><br><span class="line">		String[] postProcessorNames =</span><br><span class="line">				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);</span><br><span class="line"></span><br><span class="line">		// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span><br><span class="line">		// Ordered, and the rest.</span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		//循环BeanName数组</span><br><span class="line">		for (String ppName : postProcessorNames) &#123;</span><br><span class="line">			//如果这个Bean被执行过了，跳过</span><br><span class="line">			if (processedBeans.contains(ppName)) &#123;</span><br><span class="line">				// skip - already processed in first phase above</span><br><span class="line">			&#125;</span><br><span class="line">			//如果实现了PriorityOrdered接口，加入到priorityOrderedPostProcessors</span><br><span class="line">			else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">			&#125;</span><br><span class="line">			//如果实现了Ordered接口，加入到orderedPostProcessorNames</span><br><span class="line">			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				orderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				//如果既没有实现PriorityOrdered，也没有实现Ordered。加入到nonOrderedPostProcessorNames</span><br><span class="line">				nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//排序处理priorityOrderedPostProcessors，即实现了PriorityOrdered接口的BeanFactoryPostProcessor</span><br><span class="line">		// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span><br><span class="line">		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">		//执行priorityOrderedPostProcessors</span><br><span class="line">		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		//执行实现了Ordered接口的BeanFactoryPostProcessor</span><br><span class="line">		// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">		for (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">			orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">		&#125;</span><br><span class="line">		sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		// 执行既没有实现PriorityOrdered接口，也没有实现Ordered接口的BeanFactoryPostProcessor</span><br><span class="line">		// Finally, invoke all other BeanFactoryPostProcessors.</span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">		for (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">		&#125;</span><br><span class="line">		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		// Clear cached merged bean definitions since the post-processors might have</span><br><span class="line">		// modified the original metadata, e.g. replacing placeholders in values...</span><br><span class="line">		beanFactory.clearMetadataCache();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><a href="#ConfigurationClassPostProcessor">ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry</a></p>
<h4 id="registerBeanPostProcessors-beanFactory"><a href="#registerBeanPostProcessors-beanFactory" class="headerlink" title="registerBeanPostProcessors(beanFactory);"></a>registerBeanPostProcessors(beanFactory);</h4><h4 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource();"></a>initMessageSource();</h4><h4 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster();"></a>initApplicationEventMulticaster();</h4><h4 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh();"></a>onRefresh();</h4><h4 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners();"></a>registerListeners();</h4><h4 id="finishBeanFactoryInitialization-beanFactory"><a href="#finishBeanFactoryInitialization-beanFactory" class="headerlink" title="finishBeanFactoryInitialization(beanFactory);"></a>finishBeanFactoryInitialization(beanFactory);</h4><h4 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh();"></a>finishRefresh();</h4><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2020/08/09/Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">Spring Bean 生命周期</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页"></a></p>
        <p><span>发布时间:</span>2020-08-09, 20:38:00</p>
        <p><span>最后更新:</span>2020-08-18, 21:36:41</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2020/08/09/Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" title="Spring Bean 生命周期">https://smallwenzi.github.io/2020/08/09/Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</a>
            <span class="copy-path" data-clipboard-text="原文: https://smallwenzi.github.io/2020/08/09/Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/　　作者: " title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2020/08/09/Spring%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">
                    Spring体系结构
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9Fbean"><span class="toc-number">2.</span> <span class="toc-text">如何产生bean</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">启动过程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AnnotationConfigApplicationContext%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">AnnotationConfigApplicationContext构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GenericApplicationContext-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">GenericApplicationContext 构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DefaultListableBeanFactory-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">DefaultListableBeanFactory 构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AbstractAutowireCapableBeanFactory%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.1.1.1.</span> <span class="toc-text">AbstractAutowireCapableBeanFactory构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#AbstractBeanFactory"><span class="toc-number">3.1.1.1.1.1.</span> <span class="toc-text">AbstractBeanFactory</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AABean%E8%AF%BB%E5%8F%96%E5%99%A8AnnotatedBeanDefinitionReader"><span class="toc-number">3.1.2.</span> <span class="toc-text">&#x2F;&#x2F;初始化一个Bean读取器AnnotatedBeanDefinitionReader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AnnotatedBeanDefinitionReader%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">AnnotatedBeanDefinitionReader构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AnnotationConfigUtils-registerAnnotationConfigProcessors"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">AnnotationConfigUtils.registerAnnotationConfigProcessors</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ConfigurationClassPostProcessor"><span class="toc-number">3.1.2.2.1.</span> <span class="toc-text">ConfigurationClassPostProcessor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AutowiredAnnotationBeanPostProcessor"><span class="toc-number">3.1.2.2.2.</span> <span class="toc-text">AutowiredAnnotationBeanPostProcessor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CommonAnnotationBeanPostProcessor"><span class="toc-number">3.1.2.2.3.</span> <span class="toc-text">CommonAnnotationBeanPostProcessor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PersistenceAnnotationBeanPostProcessor"><span class="toc-number">3.1.2.2.4.</span> <span class="toc-text">PersistenceAnnotationBeanPostProcessor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#EventListenerMethodProcessor"><span class="toc-number">3.1.2.2.5.</span> <span class="toc-text">EventListenerMethodProcessor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DefaultEventListenerFactory"><span class="toc-number">3.1.2.2.6.</span> <span class="toc-text">DefaultEventListenerFactory</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#registerPostProcessor-%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">registerPostProcessor 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%89%AB%E6%8F%8F%E5%99%A8"><span class="toc-number">3.1.3.</span> <span class="toc-text">初始化扫描器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#register-componentClasses"><span class="toc-number">3.1.4.</span> <span class="toc-text">register(componentClasses);</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AnnotatedBeanDefinitionReader-%E7%B1%BBregister-%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">AnnotatedBeanDefinitionReader 类register 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AnnotatedBeanDefinitionReader-%E7%B1%BB-registerBean%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">AnnotatedBeanDefinitionReader 类 registerBean方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AnnotatedBeanDefinitionReader%E7%9A%84%E6%96%B9%E6%B3%95doRegisterBean"><span class="toc-number">3.1.4.3.</span> <span class="toc-text">AnnotatedBeanDefinitionReader的方法doRegisterBean</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#refresh"><span class="toc-number">3.1.5.</span> <span class="toc-text">refresh</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#prepareRefresh"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">prepareRefresh();</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory"><span class="toc-number">3.1.5.2.</span> <span class="toc-text">ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#prepareBeanFactory-beanFactory"><span class="toc-number">3.1.5.3.</span> <span class="toc-text">prepareBeanFactory(beanFactory);</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#postProcessBeanFactory-beanFactory"><span class="toc-number">3.1.5.4.</span> <span class="toc-text">postProcessBeanFactory(beanFactory);</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#invokeBeanFactoryPostProcessors-beanFactory"><span class="toc-number">3.1.5.5.</span> <span class="toc-text">invokeBeanFactoryPostProcessors(beanFactory);</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.5.5.1.</span> <span class="toc-text">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#registerBeanPostProcessors-beanFactory"><span class="toc-number">3.1.5.6.</span> <span class="toc-text">registerBeanPostProcessors(beanFactory);</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initMessageSource"><span class="toc-number">3.1.5.7.</span> <span class="toc-text">initMessageSource();</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initApplicationEventMulticaster"><span class="toc-number">3.1.5.8.</span> <span class="toc-text">initApplicationEventMulticaster();</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#onRefresh"><span class="toc-number">3.1.5.9.</span> <span class="toc-text">onRefresh();</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#registerListeners"><span class="toc-number">3.1.5.10.</span> <span class="toc-text">registerListeners();</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finishBeanFactoryInitialization-beanFactory"><span class="toc-number">3.1.5.11.</span> <span class="toc-text">finishBeanFactoryInitialization(beanFactory);</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finishRefresh"><span class="toc-number">3.1.5.12.</span> <span class="toc-text">finishRefresh();</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">3.2.</span> <span class="toc-text">循环依赖</span></a></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-6 i,
        .toc-level-6 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>





    




    <div class="scroll" id="post-nav-button">
        
            <a href="/" title="回到主页"><i class="fa fa-home"></i></a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2020/08/09/Spring%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" title="下一篇: Spring体系结构">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/08/09/Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">Spring Bean 生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/09/Spring%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">Spring体系结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/08/spring%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89/">springFramework源码--IOC 容器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/07/spring%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/">springFramework源码编译</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/03/omcat-%E4%B8%89%E7%A7%8D%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F/">tomcat 三种部署方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/22/bbitMq/">RabbitMq</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/22/pringSession%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89/">SpringSession源码（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/21/SpringSession%E6%BA%90%E7%A0%81/">SpringSession源码</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/21/tch-%E5%9D%91/">nutch 坑</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/21/acheHttpd%E6%97%A5%E5%BF%97%E8%AF%B4%E6%98%8E/">apacheHttpd日志说明</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/13/ring-session%EF%BC%881%EF%BC%89/">spring session（1）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/13/%E5%85%B7%E9%9B%86/">工具集</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/13/ava-%E6%9F%A5%E7%9C%8B%E5%8D%A0%E7%94%A8-CPU-%E6%9C%80%E9%AB%98%E7%9A%84%E7%BA%BF%E7%A8%8B/">[Java] 查看占用 CPU 最高的线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/29/ring-config-bus/">spring config bus</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/29/pring-admin%E9%85%8D%E7%BD%AE/">spring admin配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/29/rabbitmq-%E9%98%9F%E5%88%97%E4%BF%A1%E6%81%AF/">查询rabbitmq 队列信息</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/29/sttemplate-%E9%97%AE%E9%A2%98/">resttemplate 问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/06/A%E9%97%AE%E9%A2%98/">底层代码构造sql忽略NUll条件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/14/windows%E4%B8%8Batom%E4%B8%8A%E6%90%AD%E5%BB%BAPlantUML%E4%B9%A6%E5%86%99%E7%8E%AF%E5%A2%83/">在windows下atom上搭建PlantUML书写环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/14/olr%E7%9A%84%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8FMaster-Slave/">Solr的主从模式Master-Slave</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/13/lr%E6%95%99%E7%A8%8B/">solr教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/11/docker%E7%9A%84%E4%BD%BF%E7%94%A8/">docker的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/11/-jenkins-%E9%85%8D%E7%BD%AEmaven%E6%89%93%E5%8C%85git%E4%BB%A3%E7%A0%81/">十二 jenkins 配置maven打包git代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/11/-jenkins-%E9%85%8D%E7%BD%AEgit%E8%AF%81%E4%B9%A6/">十一 jenkins 配置git证书</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/11/enkinx-%E9%85%8D%E7%BD%AE%E4%BB%BB%E5%8A%A1/">十）jenkins 配置java和Maven环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/11/%E4%B9%9D-linux%E9%85%8D%E7%BD%AEjava%E5%92%8Cmaven/">九 linux配置java和maven</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/%E5%AE%89%E8%A3%85jenkins/">八）安装jenkins</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/ring-cloud-docker-git-maven-jenkins-Kubernetes-%E7%9B%AE%E5%BD%95/">spring cloud+docker+git+maven+jenkins+Kubernetes 目录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/%E4%B8%83%EF%BC%89maven-build-docker-and-push-Image/">七）maven build docker and push Image</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/ocker-mysql/">docker -mysql</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/%EF%BC%88%E5%85%AD%EF%BC%89docker%E5%AE%89%E8%A3%85%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%EF%BC%88root%E7%94%A8%E6%88%B7%EF%BC%89/">（六）docker安装本地仓库（root用户）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/%EF%BC%89%E6%9B%B4%E6%96%B0docker-%E7%89%88%E6%9C%AC%EF%BC%88root%E7%94%A8%E6%88%B7%EF%BC%89/">（五）更新docker 版本（root用户）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/%EF%BC%88%E5%9B%9B%EF%BC%89%E5%AE%89%E8%A3%85docker%EF%BC%88root%E7%94%A8%E6%88%B7%EF%BC%89/">（四）安装docker（root用户）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/%E4%B8%89%EF%BC%89linux-%E5%AE%89%E8%A3%85-GIT%EF%BC%88root%E7%94%A8%E6%88%B7%EF%BC%89/">（三）linux 安装 GIT（root用户）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/Red-Hat-%E5%8D%87%E7%BA%A7-rpm%E8%BD%AF%E4%BB%B6%E3%80%81YUM%E8%BD%AF%E4%BB%B6%EF%BC%88root%E7%94%A8%E6%88%B7%EF%BC%89/">(二）Red-Hat-升级-rpm软件、YUM软件（root用户）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/%EF%BC%89oracle-VM%E5%AE%89%E8%A3%85red-hat-liunx/">（一）oracle VM安装red hat liunx</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/hymeleaf%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9D%91/">thymeleaf学习的坑</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/%E9%82%A3%E4%BA%9B%E6%8F%90%E5%8D%87%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%9A%84%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/">那些提升开发人员工作效率的在线工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/%E5%8D%87%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87/">提升工作效率</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/06/tepad-compare/">Notepad++文本比较插件：Compare</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/28/gtmetix/">用GTmetrix来优化你的网页（集成了YSlow、FireBug的功能）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/20/Singleton/">java 单例模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/20/hexo%20git/">Hexo搭建githubpage博客</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2021 wen
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
    
<script src="/js/GithubRepoWidget.js"></script>


<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 1;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-25768365-2', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
             github: ".github-widget a", 
            
             post: ".article-entry a[href], .copyright a[href]", 
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>